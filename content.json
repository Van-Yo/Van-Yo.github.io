{"meta":{"title":"LittleBear's blog","subtitle":"","description":"","author":"Little Bear","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-09-18T03:37:26.297Z","updated":"2020-09-18T03:37:26.297Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-18T03:36:49.096Z","updated":"2020-09-18T03:36:49.096Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端面试必问的JS基础知识——面向对象","slug":"hello","date":"2020-09-18T08:25:06.603Z","updated":"2020-09-21T01:42:16.564Z","comments":true,"path":"2020/09/18/hello/","link":"","permalink":"http://example.com/2020/09/18/hello/","excerpt":"","text":"前言之前面试过几家公司，虽然算不上大厂，但是对js基础知识还是挺重视的。其中面试官就问了有关面向对象的几个问题，例如，1.谈谈你对面向对象的认识？2.面向对象有三大特性，是哪些，并着重介绍一下。我发现平时工作之余，太过于注重物业逻辑和框架，导致面向对象就几个字都成了最熟悉的陌生人，感觉有点印象，但又不确定，生怕说错了还给面试官留下不好的印象，所以写一个简短的博客，方便自己每次看到能勾起这段面试尴尬的回忆，和警示自己，重视基础！ 了解过面向对象的同学应该都知道，面向对象三个基本特征是：封装、继承、多态，但是对于这三个词具体可能不太了解。对于前端来讲接触最多的可能就是封装与继承，对于多态来说可能就不是那么了解了。 封装 将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。 说白了，封装就是新建一个容器，容器中定义一些属性和方法，供对象使用。 类：封装对象的属性和行为 方法：封装具体逻辑功能 访问封装：访问修饰封装无非就是对其访问权限进行封装 注：下面的代码都是基于ES6类的语法糖class来演示的。 123456789101112131415161718class Employees &#123; constructor(name,age)&#123; this.name &#x3D; name; this.age &#x3D; age; &#125; getInfo()&#123; let &#123;name,age&#125; &#x3D; this; return &#123;name,age&#125;; &#125; static seyHi()&#123; console.log(&quot;Hi&quot;); &#125;&#125;let lisi &#x3D; new Employees(&quot;Aaron&quot;,18);lisi.seyHi(); &#x2F;&#x2F; 报错 lisi.seyHi is not a functionlisi.getInfo(); &#x2F;&#x2F; &#123;name: &quot;Aaron&quot;, age: 18&#125;Employees.seyHi(); &#x2F;&#x2F; Hi 在Employees中抽出的公共属性有name,age,公共方法有getInfo,seyHi，然而getInfo与seyHi所不同的是seyHi使用了static修饰符，改变其为静态方法，seyHi只属于Employees这个类。然而getInfo方法则是属于实例的。这里使用了static对seyHi方法对其进行了访问权限的封装。再举一个Promise的例子： 1234567&#x2F;&#x2F; .then()是公共方法，属于实例Promise.then() &#x2F;&#x2F; 报错 Promise.then is not a functionlet p1 &#x3D; new Promise(() &#x3D;&gt; &#123;&#125;)p1.then(); &#x2F;&#x2F; Promise &#123;&lt;pending&gt;&#125;&#x2F;&#x2F; .all()是静态方法，只属于Promise类Promise.all([1]); &#x2F;&#x2F; Promise &#123;&lt;resolved&gt;: Array(1)&#125; 从上面的代码中可以看出Promise也使用了static对其方法的访问权限进行了封装。 继承 继承可以使得子类具有父类的各种的公有属性和公有方法。而不需要再次编写相同的代码。 子类继承父类后，子类具有父类属性和方法，然而也同样具备自己所独有的属性和方法，也就是说，子类的功能要比父类多或相同，不会比父类少。 1234567891011121314151617181920212223class Employees &#123; constructor(name)&#123; this.name &#x3D; name; &#125; getName()&#123; console.log(this.name) &#125; static seyHi()&#123; console.log(&quot;Hi&quot;); &#125;&#125;class Java extends Employees&#123; constructor(name)&#123; super(name); &#125; work()&#123; console.log(&quot;做后台工作&quot;); &#125;&#125;let java &#x3D; new Java(&quot;Aaron&quot;);java.getName(); &#x2F;&#x2F; Aaronjava.work(); &#x2F;&#x2F; 做后台工作&#x2F;&#x2F; java.seyHi(); &#x2F;&#x2F; 报错 java.seyHi is not a function 从上面的例子可以看出继承不会继承父类的静态方法，只会继承父类的公有属性与方法。这一点需要注意。子类继承之后既拥有了getName方法，同样也拥有自己的worker方法。 多态 按字面的意思就是“多种状态”，允许将子类类型的指针赋值给父类类型的指针。 说白了多态就是相同的事物，一个接口，多种实现，同时在最初的程序设定时，有可能会根据程序需求的不同，而不确定哪个函数实现，通过多态不需要修改源代码，就可以实现一个接口多种解决方案。多态的表现形式重写与重载。 重写:子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。 12345678910111213141516171819202122232425class Employees &#123; constructor(name)&#123; this.name &#x3D; name; &#125; seyHello()&#123; console.log(&quot;Hello&quot;) &#125; getName()&#123; console.log(this.name); &#125;&#125;class Java extends Employees&#123; constructor(name)&#123; super(name); &#125; seyHello()&#123; console.log(&#96;Hello,我的名字是$&#123;this.name&#125;,我是做Java工作的。&#96;) &#125;&#125;const employees &#x3D; new Employees(&quot;Aaron&quot;);const java &#x3D; new Java(&quot;Leo&quot;);employees.seyHello(); &#x2F;&#x2F; Hellojava.seyHello(); &#x2F;&#x2F; Hello,我的名字是Leo,我是做Java工作的。employees.getName(); &#x2F;&#x2F; Aaronjava.getName(); &#x2F;&#x2F; Leo 通过上面的代码可以看出Java继承了Employees,然而子类与父类中都存在seyHello方法，为了满足不同的需求子类继承父类之后重写了seyHello方法。所以在调用的时候会得到不同的结果。既然子类继承了父类，子类也同样拥有父类的getName方法。 重载就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。 因为JavaScript是没有重载的概念的所以要自己编写逻辑完成重载。 123456789101112131415161718192021222324252627282930313233343536class Employees &#123; constructor(arg)&#123; let obj &#x3D; null; switch(typeof arg) &#123; case &quot;string&quot;: obj &#x3D; new StringEmployees(arg); break; case &quot;object&quot;: obj &#x3D; new ObjEmployees(ObjEmployees); break; case &quot;number&quot;: obj &#x3D; new NumberEmployees(ObjEmployees); break; &#125; return obj; &#125;&#125;class ObjEmployees &#123; constructor(arg)&#123; console.log(&quot;ObjEmployees&quot;) &#125;&#125;class StringEmployees &#123; constructor(arg)&#123; console.log(&quot;StringEmployees&quot;) &#125;&#125;class NumberEmployees &#123; constructor(arg)&#123; console.log(&quot;NumberEmployees&quot;) &#125;&#125;new Employees(&#123;&#125;) &#x2F;&#x2F; ObjEmployeesnew Employees(&quot;123456&quot;) &#x2F;&#x2F; StringEmployeesnew Employees(987654) &#x2F;&#x2F; NumberEmployees 在上面的代码中定义了Employees,ObjEmployees,StringEmployees,NumberEmployees类,在实例化Employees的时候在constructor里面进行了判断，根据参数的不同返回不同的对应的类。这样完成了一个简单的类重载。 总结在编程的是多多运用这个写思想对其编程时很有用的，能够使你的代码达到高复用以及可维护。 封装可以隐藏实现细节，使得代码模块化； 继承可以扩展已存在的代码模块（类），它们的目的都是为了——代码重用。 多态就是相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态。","categories":[],"tags":[]},{"title":"浅谈ES6 Promise 和 ES7 Async/await的使用","slug":"await的使用","date":"2020-09-18T02:24:24.884Z","updated":"2020-09-21T01:42:16.564Z","comments":true,"path":"2020/09/18/await的使用/","link":"","permalink":"http://example.com/2020/09/18/await%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言众所周知，Javascript是单线程的，所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。当我们处理异步时，有三种常用的方法可以选择：异步回调，Promise和Async/await，接下来简述一下三者的使用区别和优缺点。 异步回调回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行，也就是B函数被作为参数传递到A函数里，在A函数执行完后再执行B，用代码表示就是如下： 12345function A(callback)&#123; callback();&#125;function B()&#123;&#125;A(B) 这也未免太简单了，是的，但现实往往就是简单的东西，项目中不会用到，太可怜了。而难的东西却一定是在简单东西基础上构建的。 那回调和异步有关系吗？回调一定是异步的吗，看上面A(B)的例子就知道，明明还是同步，所以回调并不一定就是异步，他俩并没有直接的关系。下面举一个真实的例子：有三个函数，分别是task1，task2和task3，这三个都是同步任务，并且task2必须等到task1完成后才能执行，task3执行顺序不做要求，那么常规我们会写如下代码： 12345678910111213141516171819function task1()&#123; console.log(&#39;task1&#39;);&#125;function task2()&#123; console.log(&#39;task2&#39;);&#125;function task3()&#123; console.log(&#39;task3&#39;);&#125;function testAsync()&#123; task1(); task2(); task3();&#125;testAsync();&#x2F;&#x2F; task1&#x2F;&#x2F; task2&#x2F;&#x2F; task3 这样写并没有做回调，但效果已经达到了，task2确实在task1之后执行的。那接下来使用回调： 12345678910111213141516171819function task1(task)&#123; console.log(&#39;task1&#39;); task();&#125;function task2()&#123; console.log(&#39;task2&#39;);&#125;function task3()&#123; console.log(&#39;task3&#39;);&#125;function testAsync()&#123; task1(task2); task3();&#125;testAsync();&#x2F;&#x2F; task1&#x2F;&#x2F; task2&#x2F;&#x2F; task3 输出结果一样，没有影响到task3的执行顺序，这就表明，该回调是同步回调。那什么是异步回调呢？ 因为js是单线程的，但是有很多情况的执行步骤（ajax请求远程数据，IO等）是非常耗时的，如果一直单线程的堵塞下去会导致程序的等待时间过长页面失去响应，影响用户体验了。 如何去解决这个问题呢，我们可以这么想。耗时的我们都扔给异步去做，做好了再通知下我们做完了，我们拿到数据继续往下走。 接下来利用setTimeout来模拟一个异步回调，场景就是：task1是一个要耗时很长的一个请求，task2需要用到task1请求回来的数据，而task3却跟这两个任务没有任何关系，想达到的效果就是，task1执行完之后task2再执行，但是task3可以绕过task1和task2先执行。修改代码： 12345678910111213141516171819function task1(task)&#123; setTimeout(() &#x3D;&gt; &#123; console.log(&#39;task1&#39;); task(); &#125;, 3000);&#125;function task2()&#123; console.log(&#39;task2&#39;);&#125;function task3()&#123; console.log(&#39;task3&#39;);&#125;function testAsync()&#123; task1(task2); task3();&#125;&#x2F;&#x2F; task3 然后等待3秒&#x2F;&#x2F; task1&#x2F;&#x2F; task2 上面的代码从上往下依次执行，由于task1里面setTimeout是一个异步方法，浏览器会单开一个线程去执行，所以先会去执行下面的task3同步任务，具体原理可参考JavaScript事件循环机制。 继续回到异步回调上来，在执行完任务执行时间超长的task1后，紧接着执行task2，那假如task2也是一个耗时很长的任务并且需要在其执行完之后拿到其执行完的结果呢，那是不是要往task2里面再加一个回调呢？那造成的结果可能就是传说中的地狱回调了，想想就害怕，所以Promise它带着解决方案来了！！！ PromisePromise的思想是， 每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。 Promises的出现大大改善了异步变成的困境，避免出现回调地狱，嵌套层级得到改善。他有如下API: Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 Promise.race() // 竞速，完成一个即可 传送门阮一峰大神的ECMAScript 6入门 为了使代码简介，promise的rejected状态的相关reject()和catch()方法省略： 12345678910111213141516171819202122232425262728293031task1()&#123; return new Promise((resolve,reject)&#x3D;&gt;&#123; setTimeout(() &#x3D;&gt; &#123; console.log(&#39;task1执行了&#39;); resolve(&#39;task1&#39;); &#125;, 3000); &#125;)&#125;,task2(result)&#123; return new Promise((resolve,reject)&#x3D;&gt;&#123; setTimeout(() &#x3D;&gt; &#123; console.log(&#39;task2执行了&#39;); resolve(&#39;task2收到了task1的返回值了，他的值是&#39;+result); &#125;, 3000); &#125;)&#125;,task3()&#123; console.log(&#39;task3&#39;);&#125;,testAsync()&#123; this.task1().then(res&#x3D;&gt;&#123; return this.task2(res); &#125;).then(res&#x3D;&gt;&#123; console.log(res) &#125;); this.task3();&#125;&#x2F;&#x2F; task3 等待3秒&#x2F;&#x2F; task1执行了 等待三秒&#x2F;&#x2F; task2执行了&#x2F;&#x2F; task2收到了task1的返回值了，他的值是task1 由此Promise对象还是很好用的，对于异步的流程的控制得到了大大改善，通过.then()的方法可进行链式调用。 可是 .then() .catch() 的使用也导致代码非常难看，嵌套也很深，所以async/await就出来了！！！ Async/awaitAsync/await 是Javascript编写异步程序的新方法。以往的异步方法无外乎回调函数和Promise。但是Async/await建立于Promise之上。直接上代码吧！ 12345678910111213141516171819202122232425262728293031task1()&#123; return new Promise((resolve,reject)&#x3D;&gt;&#123; setTimeout(() &#x3D;&gt; &#123; console.log(&#39;task1执行了&#39;); resolve(&#39;task1&#39;); &#125;, 3000); &#125;)&#125;,task2(result)&#123; return new Promise((resolve,reject)&#x3D;&gt;&#123; setTimeout(() &#x3D;&gt; &#123; console.log(&#39;task2执行了&#39;); resolve(&#39;task2收到了task1的返回值了，他的值是&#39;+result); &#125;, 3000); &#125;)&#125;,task3()&#123; console.log(&#39;task3&#39;);&#125;,&#x2F;&#x2F; 修改的地方async testAsync()&#123; const res1 &#x3D; await this.task1(); const res2 &#x3D; await this.task2(res1); console.log(res2); this.task3();&#125;&#x2F;&#x2F; 等待三秒&#x2F;&#x2F; task1执行了 等待三秒&#x2F;&#x2F; task2执行了&#x2F;&#x2F; task2收到了task1的返回值了，他的值是task1&#x2F;&#x2F; task3 上文中的promise 实现方法是通过then的链式调用，但是采用async会更加简洁明了，但是结果发生变化了：用同步的书写方式实现了异步的代码。 Async/await使得异步代码变的不再明显也是一点弊端咯，不过根据实际情况选择最合适的异步编程才是最好的选择。async 是 Generator 函数的语法糖。所以想更深入的理解其中内部原理的赶紧去看看 Generator 函数吧。 总结Async/await是近些年来JavaScript最具革命性的新特性之一。他让读者意识到使用Promise存在的一些问题，并提供了自身来代替Promise的方案。当然，对这个新特性也有一定的担心，体现在：他使得异步代码变的不再明显，我们好不容易已经学会并习惯了使用回调函数或者.then来处理异步，新的特性当然需要时间成本去学习和体会。","categories":[],"tags":[]}],"categories":[],"tags":[]}