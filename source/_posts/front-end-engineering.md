---
title: 前端工程化
author: Revan
index_img: /img/engineering.jpg
category: 技术
tags:
  - 前端
excerpt: 为什么这几年，前端工程化的概念突然成为了热点话题了呢？要想讲好前端工程化其实并不容易，本文从几个方面入手，对前端工程化的概念做个简单的介绍。
date: 2021-01-25 10:45:31
---

{% note info %}
虽然`前端工程化`的概念兴起还没几年的时间，但是对于“工程化”这个词并不是一个新鲜词了，在其他软件开发的领域很早就已经有了高度的工程化，例如Web服务端开发。只不过那个时候，前端工程师并没有工程化的意识，也没有必要对前端进行工程化的操作，毕竟在那个时期，前端的开发工作只能算是整个项目开发过程中的“附属品”。那为什么这几年，`前端工程化`的概念又突然成为了热点话题了呢？要想讲好`前端工程化`其实并不容易，我就从下面几个方面入手，对`前端工程化`的概念做个简单的讲解，仅仅是个人理解，希望大家多多交流讨论。[^1]
{% endnote %}

## 前端为什么要工程化？
在回答前端工程化这个问题之前，我们应该先考虑另外一个问题：`前端开发中会不会涉及到业务？`再详细一点，就是前端工程师到底需不需要了解服务端的业务逻辑，再或者说，要不要将一部分服务端的业务逻辑放到前端来实现。这个问题没有标准的答案，实际上应该属于工程协作问题，就是谁该干什么的问题。

最早的前端开发就是`实现页面`，顶多再写写JS让页面可以有`交互`的特效。但是随着需求的增加，我们不仅要做`Web`应用，还要做`App`、`小程序`以及各种端。在这种需求日增的情况下，必须得考虑一种新的方式，`优化前端的开发工作`，例如，解决代码冗余，项目可维护性，提升版本迭代速度等等一系列的问题。`前端工程化`的概念也就是在这中情况下被提出了。

## 实现前端工程化的基础——前后端分离
实际上，现在的`前端工程化`应该还处于早期阶段，毕竟前端工程师这个岗位也才诞生没几年。在互联网发展的早期，`Web`应用很多情况下都是由`服务端`工程师一肩挑，前端开发顶多是写写`HTML`代码，实现页面的布局，然后再把写好的`HTML`静态文件`交给后端工程师套模板`，因为当时大部分的Web应用都是使用的`服务端渲染`技术，例如`Java`的`JSP`。

这种`传统模式`下的协作开发效率非常低，如果在页面测试中发现了一个`bug`，这个`bug`是由于一个`ClassName`的值少写了一个字母，你说这种情况到底是前端工程师的错，还是后端工程师套模板时的粗心大意呢？毕竟一个网站上有成千上万个`DOM`节点，谁也不能保证一行代码都不会写错。再假如，项目上线后发现网页的实际像素和设计稿上存在1像素的偏差，这个时候就需要由前端工程师重新设计一次`HTML`静态页面，然后再交给后端工程师继续套模板，等整个流程走完之后，你会发现一个更加严重的问题，整个项目中仅仅是1像素的偏差，就有可能要调动`整个开发团队`来处理这1像素的问题，极大的`浪费`了团队资源。

上面的问题也仅仅是传统开发问题中的冰山一角，面对这么多的问题，`前后端分离`开发也就应运而生了。`前后端分离开发`，为`前端工程化`的发展提供了生存的土壤。随着市场需求的不断变化，前端开发从传统的`WebPage`模式，转变到`WebApp`模式，`Web`产品形态的变化也不断推动着前端工程师的工作内容发生变化。在应对各种“变化”，前端工程师们也要设计出自己的前端开发“`方法论`”。

`前端工程化`的主要目标就是`解放生产力`、`提高生产效率`。通过制定一系列的`规范`，借助`工具`和`框架`解决前端开发以及前后端协作过程中的痛点和难度问题。

## 如何实施前端工程化？
明确前后端开发的`分工`，是实现`前后端分离`的第一步，也是后面实现前端各种优化方案的基础。`前端工程师`主要负责的内容包括：

- 静态资源和动态资源的处理；
- JavaScript实现前端业务逻辑；
- HTML模板文件的产出；
- 中间层Web服务，一般由Node.js实现；
- 前端单元测试；
- 前端项目部署；

其中，`静态资源`包括`.js`文件、`.css`文件以及各种格式的`图片`、`媒体文件`等，这些文件不依赖于服务器，只需要在浏览器里面解析就可以了；`动态资源`是指`HTML`的模板，如果项目不是由服务器完成渲染的`SPA`（单页面）应用，那我们就要考虑如何实现`HTML模板`的`渲染`了。前端项目部署是指静态资源文件在测试服务器上的部署，以及HTML模板文件在Node.js中间层服务器上的部署。

从项目开发的整体环节来说，实现前端工程化还需要熟练掌握下面几个方面：

### （1）使用Webpack实现项目构建
`构建`，简单来说就是`编译`，前端开发的所有文件`最终归属`是要交给`浏览器`去解析、渲染，并将页面呈现给用户，构建就是将前端开发中的所有`源代码`转化为`宿主浏览器`可以执行的代码。前端构建产出的资源文件只有三种，`HTML`、`CSS`、`JS`文件。需要完成编译的内容有：

- 无法被浏览器直接识别的JS代码，包括ES6/7/8/9/10等符合ECMAScript规范的JS代码；
- 无法被浏览器直接识别的CSS代码，包括SASS/LESS等预编译的CSS语法；
- 无法被浏览器识别的HTML模板代码，包括jade、ejs、artTemplate、mustache等Node.js模板引擎；

`项目构建`其实就是为了弥补`浏览器自身的缺陷和不足`，是一种面向语言的`编译`过程。那么，除了针对语言本身之外，前端的构建还应该考虑到`Web`应用的`性能优化`。这些优化主要是为了`减少HTTP请求`，提升用户体验，包括：

- 依赖打包，将同步依赖的文件打包在一起，减少HTTP请求数量；
- 资源嵌入，例如将小于10kb的图片编译为base64格式嵌入文档，减少HTTP请求；
- 文件压缩，减少文件体积，缩短请求时间；
- 为文件加入hash指纹，以应对浏览器缓存策略；
- 将开发环境下的域名与静态资源文件路径修改为生产环境下的域名和路径；
- 文件名称的改变；

这里需要解释一下，前端的构建工具除了`Webpack`之外，还有其他的工具，例如`Gulp`、`Grunt`等，为什么这里只提到了`Webpack`？其实，`Gulp`、`Grunt`只能算是工作流管理工具，它们本身是不提供具体的功能，所有的`构建`、`部署`等功能都要由对应的`插件`来完成，使用`Gulp`和`Grunt`只是便于项目各个环节`工作流程`的控制。而且，这两款工具的话题热度和使用率远不及`Webpack`，`Webpack`虽然是近两年才崛起的构建工具，但目前依然成为了最流行的构建工具之一，`Vue`和`React`两大前端框架的`Webpack Loader`也是有官方或作者本人编写的。所以，我们在讲`前端工程化`构建时，推荐使用`Webpack`这款工具。

### （2）使用Babel完成JavaScript编译
`JavaScript`可以说是前端最为核心的一门编程语言了，也就是我们常说的“`JS`”，`JS`本身是可以直接在浏览器中执行的，那么为什么还要使用`Babel`再`编译`一次呢？其实，这里要解释一下，在`ECMAScript2015`（简称ES6）正式发布以后，前端工程师关注的重心就由“`JS`”转向了“`ES`”，作为专业的前端工程师们应该都了解，`JavaScript` ≠ `ECMAScript`。

`ECMAScript`是一个标准，`JavaScript`是对`ECMAScript`标准实现的一个子集。宿主浏览器的`API`（`BOM`和`DOM`）再加上`JavaScript`，就组成了我们传统认知中的`JavaScript`。但是随着`ECMAScript`的版本不断迭代更新，带来的并不是开发的便利，由于浏览器对`ECMAScript`新规范的支持实现比较滞后，即使是目前最新版的`Chrome`浏览器也没有完全支持`ECMAScript2015（ES6）`的所有规范，而且`ECMAScript2017`都已经发布了，为了更好的让新的`ES`规范能够无缝衔接浏览器，`Babel`编译`JavaScript`语法的作用就突显出来了。

`Babel`的作用简单来说，就是将浏览器未实现的`ECMAScript`规范语法转化为可运行的`低版本语法`，例如将`ES6`的`class`转化为`ES5`的`prototype`实现。

### （3）CSS预编译
`CSS`作为浏览器可以`直接识别`的样式语言，弥补了`HTML`原生样式的不足，对于早期互联网开发中，样式的要求并不复杂，仅需要少量的`CSS`代码即可。但是在如今追求用户极致体验的潮流下，`CSS`的开发要求不断提高，复杂的`CSS`开发变成一件非常繁琐和痛苦的事情。最主要的原因还是受限于浏览器的实现和`CSS`自身的弱编程能力。

`CSS`预编译器的工作原理是提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源码转化为`CSS`语法。

### （4）模块化开发
`模块化开发`和`组件化开发`是两个完全不同的概念，`模块化`属于`架构层面`的概念，`前端工程化`与`模块化`的关系就类似于组装车间与零件的关系。使用`模块化`开发，可以解决下面几个问题：

- 避免命名冲突；
- 便于依赖管理；
- 利于性能优化；
- 提高可维护性；
- 提高代码可复用性；

在`ES6`规范发布之前，`前端模块化`开发主要有三种规范，分别是：`CommonJS`、`AMD`、`CMD`。

`CommonJS`是一种只适用于`JavaScript`的静态模块化规范，适合`Node.js`开发，但并不适合浏览器环境；而`AMD`/`CMD`规范并不是完全一致的，但核心功能是统一的，两个规范都重点解决了浏览器对前端模块化的需求。

`ES6 Module`规范推出之后，前三者的模块化规范也逐渐退出前端的历史舞台。`ES6 Module`是语言层面的规范，与应用场景无关，所以一个不涉及运行环境API调用的模块可以在任何场景下运行。但是目前浏览器还没有完全支持这种规范，所以，要实现`ES6 Module`规范的话，还需要使用`构建工具`进行`编译`。

### （5）组件化开发
前面提到了，`组件化`和`模块化`是两个完全不同的概念，`模块化`是文件层面上对代码和资源的拆分，`组件化`是设计层面上对`UI`的拆分。从`UI`中拆分出来的一个`结构单元`，成为`UI`组件，一个`UI`组件单元包含了`HTML模板`、`CSS样式`、`JS逻辑`。在页面的设计过程中，页面上的每一个元素都是组件，页面也是一个组件，只不过页面是一个大型组件，然后这个大型组件又由多个中小型组件拼装而成。中型组件还可以再拆分成小型组件，小型组件再拆分成DOM元素，DOM元素也属于浏览器自身的组件，是组件的基本单元。这种组件化开发就是前端开发的“分治思想”。

### （6）开发环境的本地服务器与Mock服务
在前端工程化开发中，通过构建工具可以将代码进行编译，然后在浏览器中进行调试，但是在开发过程中源码的每次修改都需要执行一次构建，构建完成后才能在浏览器里运行，这对前端工程师来说无疑就是一种灾难。要完美的解决这个问题，`可以使用本地服务器与构建工具结合`，对源码进行监听并在修改之后触发动态构建，使用自动化构建的方式代替人工。这种动态构建是使用本地服务器解决开发层面上的问题。

`Mock服务`解决的是`前后端协作开发`的问题，前后端开发人员提前约定好`规范`，`前端工程师`通过`本地服务器`提供的`Mock数据接口`辅助前端逻辑的编写和功能模块的开发。如果项目中需要服务器端渲染（`SSR`），本地服务器还需要具备`解析HTML模板`的能力，同时Mock服务提供SSR所需的初始化数据。

前端工程师可以使用本地服务器提供的`Mock`数据接口，在后端人员开发的同时，进行前端逻辑的并行开发，等到后端真实接口开发完成后，将前端请求的地址从`Mock`服务迁移到服务器的`生产环境`即可。

### （7）规范化约束
无论是`服务器端开发`还是`前端工程化开发`，`规范化`的约束都至关重要。开发人员在设计项目的整体架构时，为了考虑到项目的可扩展性、可维护性、高内聚性等因素，会对代码进行`封装`，使用配置化操作，为项目开发带来便利，这必然要求业务代码编程范式遵循既定的`约束`。这种约束虽然带来了开发上的便捷，但是在一定程度上制约了代码的可移植性。例如，在项目中使用了某个构建工具来解决项目需求，但是如果有一天项目需要更换另一个构建工具时，代码中原有的构建工具的配置会成为冗余代码，而且不能保证这类配置不会对新构建工具产生冲突。即便是没有产生冲突，对代码的性能优化也是会带来一定负面影响的。工程化方案作为一种服务，应该尽量降低对项目产生的负面影响。这是制定`编程范式约束`规范时最重要的考虑因素。

### （8）项目部署流程化
站在前端开发的范畴来说，`项目部署`是指前端开发人员将构建产出的`代码包`部署到测试`服务器`的过程，而并非是将测试完成的代码发布到生产环境的过程。在部署过程中，要考虑`目标服务器`、`路径信息`是否与项目一一对应，并且可供负责部署到生产环境的开发人员进行配置，部署的操作流程应尽量简单。

在部署流程中，使用命令行`取代`工具执行（例如FTP）本地部署，能够极大的提高部署的速度和效率，但是这只是初级阶段的部署流程。考虑团队协作和安全方面的因素，`最佳的方式`应该是`搭建`一个可供严格审查、队列控制、操作简化的`部署平台`，并且有`专人负责`掌握流程进度。虽然这种搭建部署平台的方式在一定程度上减缓了整体的部署速度，但是加强了团队协作和安全保障。

## 前端工程化未来的发展如何？
目前，`Web`应用开发的分工模式还处于`探索期`，而且从最近流行的“大前端”的趋势来看，前端工程师的发展或许会突破`Web`领域，向多端领域发展，例如`React Native`、`Weex`、`Electron`、`小程序`等。从诞生之初“`切图仔`”到`大前端`概念，前端工程师的定位和负责的技术范畴一直在变化，但是前端工程师产出的`服务对象`永远是`用户`。在`Node.js`之前，`浏览器`是前端工程师生存的“一亩三分地”，`Node.js`的出现打破了这个局面，以致出现了“`大前端`”的发展趋势。

`Node.js`中间层+浏览器是目前实现“`大前端`”的基本模式，前端工程师掌握着与用户相关的所有资源，能够全面地掌握开发进度以及实现更合理的前后端分离方案。这种模式让前端工程师`突破`浏览器的瓶颈，迈向`Web`应用层面，这也是未来前端发展的主流趋势。

无论是专注于`浏览器`，还是兼顾了`Node.js`中间层，前端工程师的利剑始终指向的是面向浏览器的`Web`领域，`前端工程化`所提供的是一种服务，服务对象是不断参与到项目迭代过程中的前端开发人员，服务的内容涉及到`开发`、`构建`、`部署`等各个环节。

## 总结
前端工程师在未来的定位必然会发生变化，但是`前端工程化`唯一不变的原则是始终以`前端开发`为`中心`，前端工程化没有统一的行业标准，也没有固定的形态，更没有最合理的方案，只要前端工程师的定位还在不断的变化，`前端工程化`的进程将会一直持续下去。

## 参考
[^1]: [什么是前端工程化？](https://juejin.cn/post/6917447582985748493)